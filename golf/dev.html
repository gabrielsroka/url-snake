<body>
  <script>
    let d = document,
      b = d.body,
      M = Math,
      body = `Space: start/reset. Arrows: Move<div><canvas id=a><style>#a{border:solid}*{background:tan}</style>`,
      gridSize = 40,
      canvasSize = 400,
      // let alive initialise itself to undefined which is falsy
      alive,
      // don't worry about initialising score, heading, etc, we'll reset on start
      score,
      snake = [[3, 3]],
      // valid array key codes
      headings = {37:1,38:1,39:1,40:1},
      // heading stores the current heading key code - 38
      heading,
      defaultSnake = snake,
      // default the fruit to the pos of the snakes tail to save a coord
      fruit = snake[0],
      black = "#000",
      ctx,
      // we automatically times the x and y by gridsize since the all the places
      // that draw rects either need it, or they're passing 0,0. Use a bunch of 
      // default values to allow super short screen clearing
      rect = (col=black,size=canvasSize,x=0,y=x) => {
        // set a global fillStyle var so we can use it again in the text fn
        (ctx[f="fillStyle"] = col), ctx.fillRect(x*gridSize, y*gridSize, size, size);
      },
      text = (str, x=canvasSize/2, y=x, align = "center") => {
        ctx[f] = black;
        ctx.textAlign = align;
        ctx.fillText(str, x, y);
      },
      update = fakeVar => {
        if (!alive) return;
        let [headX, headY] = snake[0],
          nextX = headX + (heading)%2,
          nextY = headY + (heading-1)%2,
          collides = ([x,y])=> (x ==nextX&&y==nextY);
        // remove current tail
        snake.pop();
        // check death
        // 20
        // if([nextX,nextY].some(coord => coord<0||coord>9)||snake.some(collides))return die();
        if (
          nextX < 0 ||
          nextX > 9 ||
          nextY < 0 ||
          nextY > 9 ||
          snake.some(collides)
          )
          return die();
          // and increment the new head
          snake = [[nextX, nextY], ...snake];
        // check fruit
        if (collides(fruit)) {
          // make a copy of the tail, using the score as a proxy for snake.length-1
          snake.push([...snake[score++]]);
          // use map with an inlined fn because its shorter than declaring a fn
          // and calling it twice
          fruit = fruit.map(fakeVar=>M.floor(M.random() * 9));
        }
        // clear screen
        rect`tan`;
        // draw snake
        for ([x, y] of snake) {
          rect(black,gridSize,x,y);
        }
        // draw fruit
        rect("red",gridSize,fruit[0],fruit[1]);
        // draw score
        text(score, 9, 30, "left");
      },
      die = fakeVar => {
        alive = 0;
        rect`red`;
        // rely on default y position and text align
        text`:(`;
      },
      reset = fakeVar => {
        (alive = 1),
          (snake = [...defaultSnake]),
          (heading = 2), // heading = 40 - 38
          (score = 0);
      };
    b.innerHTML = body;
    ctx = a.getContext`2d`;
    // a is the id of the injected canvas, available globally
    a.height = a.width = canvasSize;
    // invalid font family defaults to auto
    ctx.font = "30px f";
    d.onkeyup = ({ which: w }) => {
      // if key is space and we're dead, reset. Otherwise, check if key is a valid
      // arrow key and store that key - 38 (saves a couple of bytes calculating later)
      headings[w] ? (heading=w-38) : w==32 && !alive && reset();
    };
    setInterval(update, canvasSize);
  </script>

