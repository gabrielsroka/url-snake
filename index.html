<body>
  <script>
    let d = document,
      b = d.body,
      M = Math,
      body = `Space: start/reset. Arrows: Move<div><canvas id=a><style>#a{border:solid}*{background:tan}</style>`,
      gridSize = 40,
      canvasSize = 400,
      // let alive initialise itself to undefined which is falsy
      alive,
      // don't worry about initialising score, heading, etc, we'll reset on start
      score,
      snake = [[3, 3]],
      // valid array key codes
      headings = {37:1,38:1,39:1,40:1},
      // heading stores the current heading key code - 38
      heading,
      defaultSnake = snake,
      // default the fruit to the pos of the snakes tail to save a coord
      fruit = snake[0],
      black = "#000",
      red = "red",
      rect = (x, y, col = black, w = gridSize, h = gridSize) => {
        (ctx.fillStyle = col), ctx.fillRect(x, y, w, h);
      },
      text = (str, x, y = x, align = "center") => {
        ctx.fillStyle = black;
        ctx.textAlign = align;
        ctx.fillText(str, x, y);
      },
      rand = () => M.floor(M.random() * 9),
      update = () => {
        if (!alive) return;
        let [headX, headY] = snake[0],
          nextX = headX + (heading)%2,
          nextY = headY + (heading-1)%2,
          collides = ([x,y])=> (x ==nextX&&y==nextY);
        // remove current tail
        snake.pop();
        // check death
        if (
          nextX < 0 ||
          nextX > 9 ||
          nextY < 0 ||
          nextY > 9 ||
          snake.some(collides)
          )
          return die();
          // and increment the new head
          snake = [[nextX, nextY], ...snake];
        // check fruit
        if (collides(fruit)) {
          // make a copy of the tail, using the score as a proxy for snake.length-1
          snake.push([...snake[score]]);
          score++;
          fruit = [rand(), rand()];
        }
        // clear screen
        rect(0, 0, "tan", canvasSize, canvasSize);
        // draw snake
        for ([x, y] of snake) {
          rect(x * gridSize, y * gridSize);
        }
        // draw fruit
        rect(fruit[0] * gridSize, fruit[1] * gridSize, red);
        // draw score
        text(score, 9, 30, "left");
      },
      die = () => {
        alive = 0;
        rect(0, 0, red, canvasSize, canvasSize);
        // rely on default y position and text align
        text(":(", canvasSize / 2);
      },
      reset = () => {
        (alive = 1),
          (snake = [...defaultSnake]),
          (heading = 2), // heading = 40 - 38
          (score = 0);
      };
    b.innerHTML = body;
    let ctx = a.getContext("2d");
    // a is the id of the injected canvas, available globally
    a.height = a.width = canvasSize;
    // invalid font family defaults to auto
    ctx.font = "30px f";
    d.addEventListener("keyup", ({ which: w }) => {
      headings[w] ? (heading=w-38) : w==32 && !alive && reset();
    });
    // if key is space and we're dead, reset. Otherwise, check if key is a valid
    // arrow key and store that key - 38 (saves a couple of bytes calculating later)
    setInterval(update, canvasSize);
  </script>

